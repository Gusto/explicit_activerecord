# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.


# :include: ../README.rdoc
#
# source://activesupport//lib/active_support/concern.rb#3
module ActiveSupport; end

# = Active Support \Concern
#
# A typical module looks like this:
#
#   module M
#     def self.included(base)
#       base.extend ClassMethods
#       base.class_eval do
#         scope :disabled, -> { where(disabled: true) }
#       end
#     end
#
#     module ClassMethods
#       ...
#     end
#   end
#
# By using +ActiveSupport::Concern+ the above module could instead be
# written as:
#
#   require "active_support/concern"
#
#   module M
#     extend ActiveSupport::Concern
#
#     included do
#       scope :disabled, -> { where(disabled: true) }
#     end
#
#     class_methods do
#       ...
#     end
#   end
#
# Moreover, it gracefully handles module dependencies. Given a +Foo+ module
# and a +Bar+ module which depends on the former, we would typically write the
# following:
#
#   module Foo
#     def self.included(base)
#       base.class_eval do
#         def self.method_injected_by_foo
#           ...
#         end
#       end
#     end
#   end
#
#   module Bar
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Foo # We need to include this dependency for Bar
#     include Bar # Bar is the module that Host really needs
#   end
#
# But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We
# could try to hide these from +Host+ directly including +Foo+ in +Bar+:
#
#   module Bar
#     include Foo
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar
#   end
#
# Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt>
# is the +Bar+ module, not the +Host+ class. With +ActiveSupport::Concern+,
# module dependencies are properly resolved:
#
#   require "active_support/concern"
#
#   module Foo
#     extend ActiveSupport::Concern
#     included do
#       def self.method_injected_by_foo
#         ...
#       end
#     end
#   end
#
#   module Bar
#     extend ActiveSupport::Concern
#     include Foo
#
#     included do
#       self.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar # It works, now Bar takes care of its dependencies
#   end
#
# === Prepending concerns
#
# Just like <tt>include</tt>, concerns also support <tt>prepend</tt> with a corresponding
# <tt>prepended do</tt> callback. <tt>module ClassMethods</tt> or <tt>class_methods do</tt> are
# prepended as well.
#
# <tt>prepend</tt> is also used for any dependencies.
#
# source://activesupport//lib/active_support/concern.rb#112
module ActiveSupport::Concern
  # source://activesupport//lib/active_support/concern.rb#129
  def append_features(base); end

  # Define class methods from given block.
  # You can define private class methods as well.
  #
  #   module Example
  #     extend ActiveSupport::Concern
  #
  #     class_methods do
  #       def foo; puts 'foo'; end
  #
  #       private
  #         def bar; puts 'bar'; end
  #     end
  #   end
  #
  #   class Buzz
  #     include Example
  #   end
  #
  #   Buzz.foo # => "foo"
  #   Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
  #
  # source://activesupport//lib/active_support/concern.rb#209
  def class_methods(&class_methods_module_definition); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +included+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#158
  def included(base = T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/concern.rb#142
  def prepend_features(base); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +prepended+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#175
  def prepended(base = T.unsafe(nil), &block); end

  class << self
    # source://activesupport//lib/active_support/concern.rb#125
    def extended(base); end
  end
end

# source://activesupport//lib/active_support/concern.rb#113
class ActiveSupport::Concern::MultipleIncludedBlocks < ::StandardError
  # @return [MultipleIncludedBlocks] a new instance of MultipleIncludedBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#114
  def initialize; end
end

# source://activesupport//lib/active_support/concern.rb#119
class ActiveSupport::Concern::MultiplePrependBlocks < ::StandardError
  # @return [MultiplePrependBlocks] a new instance of MultiplePrependBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#120
  def initialize; end
end

class NameError < ::StandardError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end
