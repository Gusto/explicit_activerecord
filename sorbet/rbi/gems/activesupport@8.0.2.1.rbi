# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activesupport` gem.
# Please instead update this file by running `bin/tapioca gem activesupport`.


# :include: ../README.rdoc
#
# source://activesupport//lib/active_support/concern.rb#3
module ActiveSupport; end

# = Active Support \Concern
#
# A typical module looks like this:
#
#   module M
#     def self.included(base)
#       base.extend ClassMethods
#       base.class_eval do
#         scope :disabled, -> { where(disabled: true) }
#       end
#     end
#
#     module ClassMethods
#       ...
#     end
#   end
#
# By using +ActiveSupport::Concern+ the above module could instead be
# written as:
#
#   require "active_support/concern"
#
#   module M
#     extend ActiveSupport::Concern
#
#     included do
#       scope :disabled, -> { where(disabled: true) }
#     end
#
#     class_methods do
#       ...
#     end
#   end
#
# Moreover, it gracefully handles module dependencies. Given a +Foo+ module
# and a +Bar+ module which depends on the former, we would typically write the
# following:
#
#   module Foo
#     def self.included(base)
#       base.class_eval do
#         def self.method_injected_by_foo
#           ...
#         end
#       end
#     end
#   end
#
#   module Bar
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Foo # We need to include this dependency for Bar
#     include Bar # Bar is the module that Host really needs
#   end
#
# But why should +Host+ care about +Bar+'s dependencies, namely +Foo+? We
# could try to hide these from +Host+ directly including +Foo+ in +Bar+:
#
#   module Bar
#     include Foo
#     def self.included(base)
#       base.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar
#   end
#
# Unfortunately this won't work, since when +Foo+ is included, its <tt>base</tt>
# is the +Bar+ module, not the +Host+ class. With +ActiveSupport::Concern+,
# module dependencies are properly resolved:
#
#   require "active_support/concern"
#
#   module Foo
#     extend ActiveSupport::Concern
#     included do
#       def self.method_injected_by_foo
#         ...
#       end
#     end
#   end
#
#   module Bar
#     extend ActiveSupport::Concern
#     include Foo
#
#     included do
#       self.method_injected_by_foo
#     end
#   end
#
#   class Host
#     include Bar # It works, now Bar takes care of its dependencies
#   end
#
# === Prepending concerns
#
# Just like <tt>include</tt>, concerns also support <tt>prepend</tt> with a corresponding
# <tt>prepended do</tt> callback. <tt>module ClassMethods</tt> or <tt>class_methods do</tt> are
# prepended as well.
#
# <tt>prepend</tt> is also used for any dependencies.
#
# source://activesupport//lib/active_support/concern.rb#112
module ActiveSupport::Concern
  # source://activesupport//lib/active_support/concern.rb#129
  def append_features(base); end

  # Define class methods from given block.
  # You can define private class methods as well.
  #
  #   module Example
  #     extend ActiveSupport::Concern
  #
  #     class_methods do
  #       def foo; puts 'foo'; end
  #
  #       private
  #         def bar; puts 'bar'; end
  #     end
  #   end
  #
  #   class Buzz
  #     include Example
  #   end
  #
  #   Buzz.foo # => "foo"
  #   Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)
  #
  # source://activesupport//lib/active_support/concern.rb#209
  def class_methods(&class_methods_module_definition); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +included+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#158
  def included(base = T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/concern.rb#142
  def prepend_features(base); end

  # Evaluate given block in context of base class,
  # so that you can write class macros here.
  # When you define more than one +prepended+ block, it raises an exception.
  #
  # source://activesupport//lib/active_support/concern.rb#175
  def prepended(base = T.unsafe(nil), &block); end

  class << self
    # source://activesupport//lib/active_support/concern.rb#125
    def extended(base); end
  end
end

# source://activesupport//lib/active_support/concern.rb#113
class ActiveSupport::Concern::MultipleIncludedBlocks < ::StandardError
  # @return [MultipleIncludedBlocks] a new instance of MultipleIncludedBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#114
  def initialize; end
end

# source://activesupport//lib/active_support/concern.rb#119
class ActiveSupport::Concern::MultiplePrependBlocks < ::StandardError
  # @return [MultiplePrependBlocks] a new instance of MultiplePrependBlocks
  #
  # source://activesupport//lib/active_support/concern.rb#120
  def initialize; end
end

# source://activesupport//lib/active_support/delegation.rb#14
module ActiveSupport::Delegation
  class << self
    # source://activesupport//lib/active_support/delegation.rb#21
    def generate(owner, methods, location: T.unsafe(nil), to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), nilable: T.unsafe(nil), private: T.unsafe(nil), as: T.unsafe(nil), signature: T.unsafe(nil)); end

    # source://activesupport//lib/active_support/delegation.rb#150
    def generate_method_missing(owner, target, allow_nil: T.unsafe(nil)); end
  end
end

# source://activesupport//lib/active_support/delegation.rb#18
ActiveSupport::Delegation::RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)

# source://activesupport//lib/active_support/delegation.rb#15
ActiveSupport::Delegation::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

# Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+
# option is not used.
#
# source://activesupport//lib/active_support/delegation.rb#6
class ActiveSupport::DelegationError < ::NoMethodError
  class << self
    # source://activesupport//lib/active_support/delegation.rb#8
    def nil_target(method_name, target); end
  end
end

# = \Notifications
#
# +ActiveSupport::Notifications+ provides an instrumentation API for
# Ruby.
#
# == Instrumenters
#
# To instrument an event you just need to do:
#
#   ActiveSupport::Notifications.instrument('render', extra: :information) do
#     render plain: 'Foo'
#   end
#
# That first executes the block and then notifies all subscribers once done.
#
# In the example above +render+ is the name of the event, and the rest is called
# the _payload_. The payload is a mechanism that allows instrumenters to pass
# extra information to subscribers. Payloads consist of a hash whose contents
# are arbitrary and generally depend on the event.
#
# == Subscribers
#
# You can consume those events and the information they provide by registering
# a subscriber.
#
#   ActiveSupport::Notifications.subscribe('render') do |event|
#     event.name          # => "render"
#     event.duration      # => 10 (in milliseconds)
#     event.payload       # => { extra: :information }
#     event.allocations   # => 1826 (objects)
#   end
#
# +Event+ objects record CPU time and allocations. If you don't need this
# it's also possible to pass a block that accepts five arguments:
#
#   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
#     name    # => String, name of the event (such as 'render' from above)
#     start   # => Time, when the instrumented block started execution
#     finish  # => Time, when the instrumented block ended execution
#     id      # => String, unique ID for the instrumenter that fired the event
#     payload # => Hash, the payload
#   end
#
# Here, the +start+ and +finish+ values represent wall-clock time. If you are
# concerned about accuracy, you can register a monotonic subscriber.
#
#   ActiveSupport::Notifications.monotonic_subscribe('render') do |name, start, finish, id, payload|
#     name    # => String, name of the event (such as 'render' from above)
#     start   # => Float, monotonic time when the instrumented block started execution
#     finish  # => Float, monotonic time when the instrumented block ended execution
#     id      # => String, unique ID for the instrumenter that fired the event
#     payload # => Hash, the payload
#   end
#
# For instance, let's store all "render" events in an array:
#
#   events = []
#
#   ActiveSupport::Notifications.subscribe('render') do |event|
#     events << event
#   end
#
# That code returns right away, you are just subscribing to "render" events.
# The block is saved and will be called whenever someone instruments "render":
#
#   ActiveSupport::Notifications.instrument('render', extra: :information) do
#     render plain: 'Foo'
#   end
#
#   event = events.first
#   event.name          # => "render"
#   event.duration      # => 10 (in milliseconds)
#   event.payload       # => { extra: :information }
#   event.allocations   # => 1826 (objects)
#
# If an exception happens during that particular instrumentation the payload will
# have a key <tt>:exception</tt> with an array of two elements as value: a string with
# the name of the exception class, and the exception message.
# The <tt>:exception_object</tt> key of the payload will have the exception
# itself as the value:
#
#   event.payload[:exception]         # => ["ArgumentError", "Invalid value"]
#   event.payload[:exception_object]  # => #<ArgumentError: Invalid value>
#
# As the earlier example depicts, the class ActiveSupport::Notifications::Event
# is able to take the arguments as they come and provide an object-oriented
# interface to that data.
#
# It is also possible to pass an object which responds to <tt>call</tt> method
# as the second parameter to the <tt>subscribe</tt> method instead of a block:
#
#   module ActionController
#     class PageRequest
#       def call(name, started, finished, unique_id, payload)
#         Rails.logger.debug ['notification:', name, started, finished, unique_id, payload].join(' ')
#       end
#     end
#   end
#
#   ActiveSupport::Notifications.subscribe('process_action.action_controller', ActionController::PageRequest.new)
#
# resulting in the following output within the logs including a hash with the payload:
#
#   notification: process_action.action_controller 2012-04-13 01:08:35 +0300 2012-04-13 01:08:35 +0300 af358ed7fab884532ec7 {
#      controller: "Devise::SessionsController",
#      action: "new",
#      params: {"action"=>"new", "controller"=>"devise/sessions"},
#      format: :html,
#      method: "GET",
#      path: "/login/sign_in",
#      status: 200,
#      view_runtime: 279.3080806732178,
#      db_runtime: 40.053
#    }
#
# You can also subscribe to all events whose name matches a certain regexp:
#
#   ActiveSupport::Notifications.subscribe(/render/) do |*args|
#     ...
#   end
#
# and even pass no argument to <tt>subscribe</tt>, in which case you are subscribing
# to all events.
#
# == Temporary Subscriptions
#
# Sometimes you do not want to subscribe to an event for the entire life of
# the application. There are two ways to unsubscribe.
#
# WARNING: The instrumentation framework is designed for long-running subscribers,
# use this feature sparingly because it wipes some internal caches and that has
# a negative impact on performance.
#
# === Subscribe While a Block Runs
#
# You can subscribe to some event temporarily while some block runs. For
# example, in
#
#   callback = lambda {|event| ... }
#   ActiveSupport::Notifications.subscribed(callback, "sql.active_record") do
#     ...
#   end
#
# the callback will be called for all "sql.active_record" events instrumented
# during the execution of the block. The callback is unsubscribed automatically
# after that.
#
# To record +started+ and +finished+ values with monotonic time,
# specify the optional <tt>:monotonic</tt> option to the
# <tt>subscribed</tt> method. The <tt>:monotonic</tt> option is set
# to +false+ by default.
#
#   callback = lambda {|name, started, finished, unique_id, payload| ... }
#   ActiveSupport::Notifications.subscribed(callback, "sql.active_record", monotonic: true) do
#     ...
#   end
#
# === Manual Unsubscription
#
# The +subscribe+ method returns a subscriber object:
#
#   subscriber = ActiveSupport::Notifications.subscribe("render") do |event|
#     ...
#   end
#
# To prevent that block from being called anymore, just unsubscribe passing
# that reference:
#
#   ActiveSupport::Notifications.unsubscribe(subscriber)
#
# You can also unsubscribe by passing the name of the subscriber object. Note
# that this will unsubscribe all subscriptions with the given name:
#
#   ActiveSupport::Notifications.unsubscribe("render")
#
# Subscribers using a regexp or other pattern-matching object will remain subscribed
# to all events that match their original pattern, unless those events match a string
# passed to +unsubscribe+:
#
#   subscriber = ActiveSupport::Notifications.subscribe(/render/) { }
#   ActiveSupport::Notifications.unsubscribe('render_template.action_view')
#   subscriber.matches?('render_template.action_view') # => false
#   subscriber.matches?('render_partial.action_view') # => true
#
# == Default Queue
#
# Notifications ships with a queue implementation that consumes and publishes events
# to all log subscribers. You can use any queue implementation you want.
#
# source://activesupport//lib/active_support/notifications/instrumenter.rb#7
module ActiveSupport::Notifications
  class << self
    # source://activesupport//lib/active_support/notifications.rb#208
    def instrument(name, payload = T.unsafe(nil)); end

    # source://activesupport//lib/active_support/notifications.rb#269
    def instrumenter; end

    # Performs the same functionality as #subscribe, but the +start+ and
    # +finish+ block arguments are in monotonic time instead of wall-clock
    # time. Monotonic time will not jump forward or backward (due to NTP or
    # Daylights Savings). Use +monotonic_subscribe+ when accuracy of time
    # duration is important. For example, computing elapsed time between
    # two events.
    #
    # source://activesupport//lib/active_support/notifications.rb#254
    def monotonic_subscribe(pattern = T.unsafe(nil), callback = T.unsafe(nil), &block); end

    # Returns the value of attribute notifier.
    #
    # source://activesupport//lib/active_support/notifications.rb#198
    def notifier; end

    # Sets the attribute notifier
    #
    # @param value the value to set the attribute notifier to.
    #
    # source://activesupport//lib/active_support/notifications.rb#198
    def notifier=(_arg0); end

    # source://activesupport//lib/active_support/notifications.rb#200
    def publish(name, *args); end

    # source://activesupport//lib/active_support/notifications.rb#204
    def publish_event(event); end

    # Subscribe to a given event name with the passed +block+.
    #
    # You can subscribe to events by passing a String to match exact event
    # names, or by passing a Regexp to match all events that match a pattern.
    #
    # If the block passed to the method only takes one argument,
    # it will yield an +Event+ object to the block:
    #
    #   ActiveSupport::Notifications.subscribe(/render/) do |event|
    #     @event = event
    #   end
    #
    # Otherwise the +block+ will receive five arguments with information
    # about the event:
    #
    #   ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload|
    #     name    # => String, name of the event (such as 'render' from above)
    #     start   # => Time, when the instrumented block started execution
    #     finish  # => Time, when the instrumented block ended execution
    #     id      # => String, unique ID for the instrumenter that fired the event
    #     payload # => Hash, the payload
    #   end
    #
    # Raises an error if invalid event name type is passed:
    #
    #   ActiveSupport::Notifications.subscribe(:render) {|event| ...}
    #   #=> ArgumentError (pattern must be specified as a String, Regexp or empty)
    #
    # source://activesupport//lib/active_support/notifications.rb#244
    def subscribe(pattern = T.unsafe(nil), callback = T.unsafe(nil), &block); end

    # source://activesupport//lib/active_support/notifications.rb#258
    def subscribed(callback, pattern = T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

    # source://activesupport//lib/active_support/notifications.rb#265
    def unsubscribe(subscriber_or_name); end

    private

    # source://activesupport//lib/active_support/notifications.rb#274
    def registry; end
  end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#106
class ActiveSupport::Notifications::Event
  # @return [Event] a new instance of Event
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#110
  def initialize(name, start, ending, transaction_id, payload); end

  # Returns the number of allocations made between the call to #start! and
  # the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#176
  def allocations; end

  # Returns the CPU time (in milliseconds) passed between the call to
  # #start! and the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#163
  def cpu_time; end

  # Returns the difference in milliseconds between when the execution of the
  # event started and when it ended.
  #
  #   ActiveSupport::Notifications.subscribe('wait') do |event|
  #     @event = event
  #   end
  #
  #   ActiveSupport::Notifications.instrument('wait') do
  #     sleep 1
  #   end
  #
  #   @event.duration # => 1000.138
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#198
  def duration; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#128
  def end; end

  # Record information at the time this event finishes
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#154
  def finish!; end

  # Returns the time spent in GC (in milliseconds) between the call to #start!
  # and the call to #finish!
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#182
  def gc_time; end

  # Returns the idle time time (in milliseconds) passed between the call to
  # #start! and the call to #finish!.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#169
  def idle_time; end

  # Returns the value of attribute name.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#107
  def name; end

  # Returns the value of attribute payload.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#108
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#108
  def payload=(_arg0); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#132
  def record; end

  # Record information at the time this event starts
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#146
  def start!; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#124
  def time; end

  # Returns the value of attribute transaction_id.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#107
  def transaction_id; end

  private

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#203
  def now; end

  # Likely on JRuby, TruffleRuby
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#230
  def now_allocations; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#210
  def now_cpu; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#220
  def now_gc; end
end

# This is a default queue implementation that ships with Notifications.
# It just pushes events to all registered log subscribers.
#
# This class is thread safe. All methods are reentrant.
#
# source://activesupport//lib/active_support/notifications/fanout.rb#49
class ActiveSupport::Notifications::Fanout
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [Fanout] a new instance of Fanout
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#50
  def initialize; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#297
  def all_listeners_for(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#272
  def build_handle(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#101
  def clear_cache(key = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#283
  def finish(name, id, payload, listeners = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#187
  def groups_for(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#59
  def inspect; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#306
  def listeners_for(name); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#310
  def listening?(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#289
  def publish(name, *args); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#293
  def publish_event(event); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#276
  def start(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#64
  def subscribe(pattern = T.unsafe(nil), callable = T.unsafe(nil), monotonic: T.unsafe(nil), &block); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#81
  def unsubscribe(subscriber_or_name); end

  # This is a sync queue, so there is no waiting.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#315
  def wait; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#113
class ActiveSupport::Notifications::Fanout::BaseGroup
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [BaseGroup] a new instance of BaseGroup
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#116
  def initialize(listeners, name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#120
  def each(&block); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#125
class ActiveSupport::Notifications::Fanout::BaseTimeGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#130
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#126
  def start(name, id, payload); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#166
class ActiveSupport::Notifications::Fanout::EventObjectGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#172
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#167
  def start(name, id, payload); end

  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#182
  def build_event(name, id, payload); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#152
class ActiveSupport::Notifications::Fanout::EventedGroup < ::ActiveSupport::Notifications::Fanout::BaseGroup
  # source://activesupport//lib/active_support/notifications/fanout.rb#159
  def finish(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#153
  def start(name, id, payload); end
end

# A +Handle+ is used to record the start and finish time of event.
#
# Both #start and #finish must each be called exactly once.
#
# Where possible, it's best to use the block form: ActiveSupport::Notifications.instrument.
# +Handle+ is a low-level API intended for cases where the block form can't be used.
#
#   handle = ActiveSupport::Notifications.instrumenter.build_handle("my.event", {})
#   begin
#     handle.start
#     # work to be instrumented
#   ensure
#     handle.finish
#   end
#
# source://activesupport//lib/active_support/notifications/fanout.rb#227
class ActiveSupport::Notifications::Fanout::Handle
  include ::ActiveSupport::Notifications::FanoutIteration

  # @return [Handle] a new instance of Handle
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#230
  def initialize(notifier, name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#249
  def finish; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#253
  def finish_with_values(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#240
  def start; end

  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#263
  def ensure_state!(expected); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#138
class ActiveSupport::Notifications::Fanout::MonotonicTimedGroup < ::ActiveSupport::Notifications::Fanout::BaseTimeGroup
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#140
  def now; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#318
module ActiveSupport::Notifications::Fanout::Subscribers
  class << self
    # source://activesupport//lib/active_support/notifications/fanout.rb#319
    def new(pattern, listener, monotonic); end
  end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#433
class ActiveSupport::Notifications::Fanout::Subscribers::EventObject < ::ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # source://activesupport//lib/active_support/notifications/fanout.rb#434
  def group_class; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#438
  def publish_event(event); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#375
class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # @return [Evented] a new instance of Evented
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#378
  def initialize(pattern, delegate); end

  # Returns the value of attribute delegate.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#376
  def delegate; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#386
  def group_class; end

  # Returns the value of attribute pattern.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#376
  def pattern; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#390
  def publish(name, *args); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#396
  def publish_event(event); end

  # Returns the value of attribute silenceable.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#376
  def silenceable; end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#404
  def silenced?(name); end

  # @return [Boolean]
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#408
  def subscribed_to?(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#412
  def unsubscribe!(name); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#338
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#351
  def initialize(pattern); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#360
  def ===(name); end

  # Returns the value of attribute exclusions.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#339
  def exclusions; end

  # Returns the value of attribute pattern.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#339
  def pattern; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#356
  def unsubscribe!(name); end

  class << self
    # source://activesupport//lib/active_support/notifications/fanout.rb#341
    def wrap(pattern); end
  end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#364
class ActiveSupport::Notifications::Fanout::Subscribers::Matcher::AllMessages
  # source://activesupport//lib/active_support/notifications/fanout.rb#365
  def ===(name); end

  # source://activesupport//lib/active_support/notifications/fanout.rb#369
  def unsubscribe!(*_arg0); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#427
class ActiveSupport::Notifications::Fanout::Subscribers::MonotonicTimed < ::ActiveSupport::Notifications::Fanout::Subscribers::Timed
  # source://activesupport//lib/active_support/notifications/fanout.rb#428
  def group_class; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#417
class ActiveSupport::Notifications::Fanout::Subscribers::Timed < ::ActiveSupport::Notifications::Fanout::Subscribers::Evented
  # source://activesupport//lib/active_support/notifications/fanout.rb#418
  def group_class; end

  # source://activesupport//lib/active_support/notifications/fanout.rb#422
  def publish(name, *args); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#145
class ActiveSupport::Notifications::Fanout::TimedGroup < ::ActiveSupport::Notifications::Fanout::BaseTimeGroup
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#147
  def now; end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#18
module ActiveSupport::Notifications::FanoutIteration
  private

  # source://activesupport//lib/active_support/notifications/fanout.rb#20
  def iterate_guarding_exceptions(collection); end
end

# source://activesupport//lib/active_support/notifications/fanout.rb#8
class ActiveSupport::Notifications::InstrumentationSubscriberError < ::RuntimeError
  # @return [InstrumentationSubscriberError] a new instance of InstrumentationSubscriberError
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#11
  def initialize(exceptions); end

  # Returns the value of attribute exceptions.
  #
  # source://activesupport//lib/active_support/notifications/fanout.rb#9
  def exceptions; end
end

# Instrumenters are stored in a thread local.
#
# source://activesupport//lib/active_support/notifications/instrumenter.rb#9
class ActiveSupport::Notifications::Instrumenter
  # @return [Instrumenter] a new instance of Instrumenter
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#12
  def initialize(notifier); end

  # Returns a "handle" for an event with the given +name+ and +payload+.
  #
  # #start and #finish must each be called exactly once on the returned object.
  #
  # Where possible, it's best to use #instrument, which will record the
  # start and finish of the event and correctly handle any exceptions.
  # +build_handle+ is a low-level API intended for cases where using
  # +instrument+ isn't possible.
  #
  # See ActiveSupport::Notifications::Fanout::Handle.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#78
  def build_handle(name, payload); end

  # Send a finish notification with +name+ and +payload+.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#92
  def finish(name, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#96
  def finish_with_state(listeners_state, name, payload); end

  # Returns the value of attribute id.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#10
  def id; end

  # Given a block, instrument it by measuring the time taken to execute
  # and publish it. Without a block, simply send a message via the
  # notifier. Notice that events get sent even if an error occurs in the
  # passed-in block.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#54
  def instrument(name, payload = T.unsafe(nil)); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#82
  def new_event(name, payload = T.unsafe(nil)); end

  # Send a start notification with +name+ and +payload+.
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#87
  def start(name, payload); end

  private

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#101
  def unique_id; end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#21
class ActiveSupport::Notifications::Instrumenter::LegacyHandle
  # @return [LegacyHandle] a new instance of LegacyHandle
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#34
  def initialize(notifier, name, id, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#45
  def finish; end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#41
  def start; end
end

# source://activesupport//lib/active_support/notifications/instrumenter.rb#22
class ActiveSupport::Notifications::Instrumenter::LegacyHandle::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://activesupport//lib/active_support/notifications/instrumenter.rb#23
  def initialize(notifier); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#27
  def build_handle(name, id, payload); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#31
  def finish(*_arg0, **_arg1, &_arg2); end

  # source://activesupport//lib/active_support/notifications/instrumenter.rb#31
  def start(*_arg0, **_arg1, &_arg2); end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#6
module ActiveSupport::Tryable
  # source://activesupport//lib/active_support/core_ext/object/try.rb#7
  def try(*args, **_arg1, &block); end

  # source://activesupport//lib/active_support/core_ext/object/try.rb#20
  def try!(*args, **_arg1, &block); end
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#117
class Delegator < ::BasicObject
  include ::ActiveSupport::Tryable
end

# == Attribute Accessors per Thread
#
# Extends the module object with class/module and instance accessors for
# class/module attributes, just like the native attr* accessors for instance
# attributes, but does so on a per-thread basis.
#
# So the values are scoped within the Thread.current space under the class name
# of the module.
#
# Note that it can also be scoped per-fiber if +Rails.application.config.active_support.isolation_level+
# is set to +:fiber+.
#
# source://activesupport//lib/active_support/core_ext/module/delegation.rb#3
class Module
  # Provides a +delegate+ class method to easily expose contained objects'
  # public methods as your own.
  #
  # ==== Options
  # * <tt>:to</tt> - Specifies the target object name as a symbol or string
  # * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix
  # * <tt>:allow_nil</tt> - If set to true, prevents a +ActiveSupport::DelegationError+
  #   from being raised
  # * <tt>:private</tt> - If set to true, changes method visibility to private
  #
  # The macro receives one or more method names (specified as symbols or
  # strings) and the name of the target object via the <tt>:to</tt> option
  # (also a symbol or string).
  #
  # Delegation is particularly useful with Active Record associations:
  #
  #   class Greeter < ActiveRecord::Base
  #     def hello
  #       'hello'
  #     end
  #
  #     def goodbye
  #       'goodbye'
  #     end
  #   end
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, to: :greeter
  #   end
  #
  #   Foo.new.hello   # => "hello"
  #   Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>
  #
  # Multiple delegates to the same target are allowed:
  #
  #   class Foo < ActiveRecord::Base
  #     belongs_to :greeter
  #     delegate :hello, :goodbye, to: :greeter
  #   end
  #
  #   Foo.new.goodbye # => "goodbye"
  #
  # Methods can be delegated to instance variables, class variables, or constants
  # by providing them as a symbols:
  #
  #   class Foo
  #     CONSTANT_ARRAY = [0,1,2,3]
  #     @@class_array  = [4,5,6,7]
  #
  #     def initialize
  #       @instance_array = [8,9,10,11]
  #     end
  #     delegate :sum, to: :CONSTANT_ARRAY
  #     delegate :min, to: :@@class_array
  #     delegate :max, to: :@instance_array
  #   end
  #
  #   Foo.new.sum # => 6
  #   Foo.new.min # => 4
  #   Foo.new.max # => 11
  #
  # It's also possible to delegate a method to the class by using +:class+:
  #
  #   class Foo
  #     def self.hello
  #       "world"
  #     end
  #
  #     delegate :hello, to: :class
  #   end
  #
  #   Foo.new.hello # => "world"
  #
  # Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value
  # is <tt>true</tt>, the delegate methods are prefixed with the name of the object being
  # delegated to.
  #
  #   Person = Struct.new(:name, :address)
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: true
  #   end
  #
  #   john_doe = Person.new('John Doe', 'Vimmersvej 13')
  #   invoice = Invoice.new(john_doe)
  #   invoice.client_name    # => "John Doe"
  #   invoice.client_address # => "Vimmersvej 13"
  #
  # It is also possible to supply a custom prefix.
  #
  #   class Invoice < Struct.new(:client)
  #     delegate :name, :address, to: :client, prefix: :customer
  #   end
  #
  #   invoice = Invoice.new(john_doe)
  #   invoice.customer_name    # => 'John Doe'
  #   invoice.customer_address # => 'Vimmersvej 13'
  #
  # The delegated methods are public by default.
  # Pass <tt>private: true</tt> to change that.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :first_name, to: :profile
  #     delegate :date_of_birth, to: :profile, private: true
  #
  #     def age
  #       Date.today.year - date_of_birth.year
  #     end
  #   end
  #
  #   User.new.first_name # => "Tomas"
  #   User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340>
  #   User.new.age # => 2
  #
  # If the target is +nil+ and does not respond to the delegated method a
  # +ActiveSupport::DelegationError+ is raised. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile
  #   end
  #
  #   User.new.age
  #   # => ActiveSupport::DelegationError: User#age delegated to profile.age, but profile is nil
  #
  # But if not having a profile yet is fine and should not be an error
  # condition:
  #
  #   class User < ActiveRecord::Base
  #     has_one :profile
  #     delegate :age, to: :profile, allow_nil: true
  #   end
  #
  #   User.new.age # nil
  #
  # Note that if the target is not +nil+ then the call is attempted regardless of the
  # <tt>:allow_nil</tt> option, and thus an exception is still raised if said object
  # does not respond to the method:
  #
  #   class Foo
  #     def initialize(bar)
  #       @bar = bar
  #     end
  #
  #     delegate :name, to: :@bar, allow_nil: true
  #   end
  #
  #   Foo.new("Bar").name # raises NoMethodError: undefined method `name'
  #
  # The target method must be public, otherwise it will raise +NoMethodError+.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#160
  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil), private: T.unsafe(nil)); end

  # When building decorators, a common pattern may emerge:
  #
  #   class Partition
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #
  #     private
  #       def respond_to_missing?(name, include_private = false)
  #         @event.respond_to?(name, include_private)
  #       end
  #
  #       def method_missing(method, *args, &block)
  #         @event.send(method, *args, &block)
  #       end
  #   end
  #
  # With <tt>Module#delegate_missing_to</tt>, the above is condensed to:
  #
  #   class Partition
  #     delegate_missing_to :@event
  #
  #     def initialize(event)
  #       @event = event
  #     end
  #
  #     def person
  #       detail.person || creator
  #     end
  #   end
  #
  # The target can be anything callable within the object, e.g. instance
  # variables, methods, constants, etc.
  #
  # The delegated method must be public on the target, otherwise it will
  # raise +ActiveSupport::DelegationError+. If you wish to instead return +nil+,
  # use the <tt>:allow_nil</tt> option.
  #
  # The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from
  # delegation due to possible interference when calling
  # <tt>Marshal.dump(object)</tt>, should the delegation target method
  # of <tt>object</tt> add or remove instance variables.
  #
  # source://activesupport//lib/active_support/core_ext/module/delegation.rb#218
  def delegate_missing_to(target, allow_nil: T.unsafe(nil)); end
end

# source://activesupport//lib/active_support/core_ext/module/delegation.rb#5
Module::DelegationError = ActiveSupport::DelegationError

class NameError < ::StandardError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

# source://activesupport//lib/active_support/core_ext/object/try.rb#137
class NilClass
  # Calling +try+ on +nil+ always returns +nil+.
  # It becomes especially helpful when navigating through associations that may return +nil+.
  #
  #   nil.try(:name) # => nil
  #
  # Without +try+
  #   @person && @person.children.any? && @person.children.first.name
  #
  # With +try+
  #   @person.try(:children).try(:first).try(:name)
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#148
  def try(*_arg0); end

  # Calling +try!+ on +nil+ always returns +nil+.
  #
  #   nil.try!(:name) # => nil
  #
  # source://activesupport//lib/active_support/core_ext/object/try.rb#155
  def try!(*_arg0); end
end

# --
# Most objects are cloneable, but not all. For example you can't dup methods:
#
#   method(:puts).dup # => TypeError: allocator undefined for Method
#
# Classes may signal their instances are not duplicable removing +dup+/+clone+
# or raising exceptions from them. So, to dup an arbitrary object you normally
# use an optimistic approach and are ready to catch an exception, say:
#
#   arbitrary_object.dup rescue object
#
# Rails dups objects in a few critical spots where they are not that arbitrary.
# That rescue is very expensive (like 40 times slower than a predicate), and it
# is often triggered.
#
# That's why we hardcode the following cases and check duplicable? instead of
# using that rescue idiom.
# ++
#
# source://activesupport//lib/active_support/core_ext/object/try.rb#35
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::ActiveSupport::Tryable
end
